// Hi Emacs, this is -*- coding: utf-8; mode: c++; tab-width: 6; indent-tabs-mode: nil; c-basic-offset: 6 -*-
#include "slip.h"
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

/* SLIP special character codes
 */
#define END             192    /* indicates end of packet */
#define ESC             219    /* indicates byte stuffing */
#define ESC_END         220    /* ESC ESC_END means END data byte */
#define ESC_ESC         221    /* ESC ESC_ESC means ESC data byte */

using teletraffic::Slip;


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Slip::Slip(int fd) {
       fd_ = fd;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Slip::~Slip() {
}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int Slip::Send(uint8_t* p, int  len) {

      /* send an initial END character to flush out any data that may
       * have accumulated in the receiver due to line noise
       */
      send_char(END);

      /* for each byte in the packet, send the appropriate character
       * sequence
       */
      while(len--) {
            switch(*p) {
                  /* if it's the same code as an END character, we send a
                   * special two character code so as not to make the
                   * receiver think we sent an END
                   */
            case END:
                  send_char(ESC);
                  send_char(ESC_END);
                  break;

                  /* if it's the same code as an ESC character,
                   * we send a special two character code so as not
                   * to make the receiver think we sent an ESC
                   */
            case ESC:
                  send_char(ESC);
                  send_char(ESC_ESC);
                  break;
                  /* otherwise, we just send the character
                   */
            default:
                  send_char(*p);
            }

            p++;
      }

      /* tell the receiver that we're done sending the packet
       */
      send_char(END);
      
      return 0;
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/* RECV_PACKET: receives a packet into the buffer located at "p".
 *      If more than len bytes are received, the packet will
 *      be truncated.
 *      Returns the number of bytes stored in the buffer.
 */
int Slip::Recv(uint8_t* p, int len) {
      
      uint8_t c;
      int received = 0;

      
      /* sit in a loop reading bytes until we put together
       * a whole packet.
       * Make sure not to copy them into the packet if we
       * run out of room.
       */
      while(1) {
            /* get a character to process
             */
            recv_char(&c);

            /* handle bytestuffing if necessary
             */
            switch(c) {

                  /* if it's an END character then we're done with
                   * the packet
                   */
            case END:
                  /* a minor optimization: if there is no
                   * data in the packet, ignore it. This is
                   * meant to avoid bothering IP with all
                   * the empty packets generated by the
                   * duplicate END characters which are in
                   * turn sent to try to detect line noise.
                   */
                  if(received)
                        return received;
                  else
                        break;

                  /* if it's the same code as an ESC character, wait
                   * and get another character and then figure out
                   * what to store in the packet based on that.
                   */
            case ESC:
                  recv_char(&c);

                  /* if "c" is not one of these two, then we
                   * have a protocol violation.  The best bet
                   * seems to be to leave the byte alone and
                   * just stuff it into the packet
                   */
                  switch(c) {
                  case ESC_END:
                        c = END;
                        break;
                  case ESC_ESC:
                        c = ESC;
                        break;
                  }

                  /* here we fall into the default handler and let
                   * it store the character for us
                   */
            default:
                  if(received < len)
                        p[received++] = c;
            }
      }

      return 0;
}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int Slip::send_char(uint8_t  c) {
      int n;
      n = write(fd_, &c, 1);
      if (n != 1) {
            return 1;
      }
      return 0;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int Slip::recv_char(uint8_t* c) {
      int n;
      uint8_t buff[1];
      n = read(fd_, buff, 1);
      *c = buff[0];
      if (n != 1) {
            return 1;
      }

      return 0;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////




